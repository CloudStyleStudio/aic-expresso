#summary Brewer Overview

The tasks of parsing human-readable strings into expressions and, conversely, transforming expressions into human-readable strings are left to the _brewer_ package, which implements a parser and a writer of expressions. Since the original implementation, the brewer parser has been largely replaced by a faster [http://www.antlr.org/ ANTLR-generated parser]. However, it is kept around because the grammar used by brewer is also used for _outputting_ expressions as strings. Therefore, we keep their descriptions here, while noting that understanding these details is not going to be necessary for most developers.

The parser can take a grammar definition, which is a mapping from non-terminal symbols names to parsing expressions (which are themselves, incidentally, extensions of the expressions defined by the _expresso_ package). The parsing expressions can be, at their simplest, terminal symbols supposed to appear verbatim in the input, a symbol parsing expression, which accepts symbols, including quoted ones containing spaces in the middle, non-terminal parsing expressions referring to a parsing expression defined under a certain name, or more complex combinations of other parsing expressions, such as disjunctions, sequences, kleene operators, and optional parsing expressions. Perhaps the most important parsing expression is the `Sequence`, which represents a sequence of other parsing expressions. This allows the specification of English-like operator syntax such as `message from . to .`, where the dots represent arguments. Operators of these form are called _mixfix_, since they use a mix of prefix, infix, and postfix notation. Another mixfix operator is the extensional set definition `{ . }`, where the argument can be an expression or a kleene list of expressions. The class `CommonGrammar` defines several parsing expressions we currently use.   