#summary Brewer Overview

The tasks of parsing human-readable strings into expressions and, conversely, transforming expressions into human-readable strings are left to the _brewer_ package, which implements a parser and a writer of expressions. Since the original implementation, the brewer parser has been largely replaced by a faster [http://www.antlr.org/ ANTLR-generated parser]. However, it is kept around because the grammar used by brewer is also used for _outputting_ expressions as strings. Therefore, we keep their descriptions here, while noting that understanding these details is not going to be necessary for most developers.

The parser can take a grammar definition, which is a mapping from non-terminal symbol names to parsing expressions (which are themselves, incidentally, extensions of the expressions defined by the _expresso_ package). The parsing expressions can be, at their simplest, terminal symbols supposed to appear verbatim in the input, a symbol parsing expression, which accepts symbols, including quoted ones containing spaces in the middle, non-terminal parsing expressions referring to a parsing expression defined under a certain name, or more complex combinations of other parsing expressions, such as disjunctions, sequences, kleene operators, and optional parsing expressions. Perhaps the most important parsing expression is the `Sequence`, which represents a sequence of other parsing expressions. This allows the specification of English-like operator syntax such as `message from . to .`, where the dots represent arguments. Operators of these form are called _mixfix_, since they use a mix of prefix, infix, and postfix notation. Another mixfix operator is the extensional set definition `{ . }`, where the argument can be an expression or a kleene list of expressions. The class `CommonGrammar` defines several parsing expressions we currently use.

Perhaps the most important thing to know about brewer is how it decides which symbols to represent functions with. A sequence of terminals and arguments of the form 

`Terminal("message") Terminal("from") NonTerminal("Expression") Terminal("to") NonTerminal("Expression")`

generates function applications with a functor equal to symbol '`message from . to .`'. That is, the sequence gathers the terminal symbols in the sequence and leaves dots for everything that is not a terminal, considered to be the arguments. (Note that writing `message from A to B` is equivalent to writing `'message from . to .'(A, B)`.) The exceptions for that name forming procedure is unary prefix operators such as 

`Terminal("max") NonTerminal("Expression")`

and binary infix operators such as

`NonTerminal("Expression") NonTerminal("+") NonTerminal("Expression")`

which generate applications of function symbols `max` and `+`, without the dots, since this better agrees with human conventions.

Operator precedence is established by the order of disjuncts in a `Disjunction` parsing expression: those appearing first have lower precedence than those appearing later.

Note that the parser implemented by _brewer_ is interpreted, not compiled as the ones produced by parser generators such as [http://www.antlr.org/ ANTLR] and [http://java.net/projects/javacc JavaCC]. This design decision is based on the future need for users to be able to declare their own operators (possibly mixfix) at run-time, something that changes the grammar on the fly. At this point the parser is horribly slow; optimizations on that are first priority at the time of this writing.

We do not dwell on the brewer library for now since it will be one of the least modified. We recommend a look at the grammar defined in the class `CommonGrammar`. More details can be found in the code documentation itself. 

A `Writer` is the inverse of the parser, writing down expression Java objects as strings. The expresso library does not depend on brewer in any way, but the class `AbstractSyntaxTree` has a field `threadToString` which is a cache of functions (on a per-thread basis) that can be set in any way, and will use such a function as its `toString()` implementation. The user can provide an instance of `WriterToStringFunction`, with a desired `Writer` as such a function and have it replace the default printing in `AbstractSyntaxTree`.    