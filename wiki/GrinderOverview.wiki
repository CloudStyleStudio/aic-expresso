#summary Grinder Overview

=Overview=

Java programmers can use the _expresso_ and _brewer_ packages to represent and construct expressions, and then use them any way they like, as any other type of Java objects. One possible way of using them is in a [http://en.wikipedia.org/wiki/Rewriting Rewriting System], in which expressions (and parts of expressions) are iteratively rewritten until no further rewriting is possible (not unlike the way people sometimes work out expressions in informal mathematics). The _grinder_ pacakge provides support for this kind of use.

The way grinder operates is simple. A rewriter can be seen as a function mapping each expression into another, possibly itself (this latter case is interpreted as the rewriter "not applying" to that expression). Grinder takes one rewriter and one expression, and applies the rewriter to the expression, returning the result.

Naturally, it is more common to successively apply several rewriters to an expression. This can be done by using an "aggregation" rewriter called `RewriteOnce`. This rewriter is based on a sorted list of other rewriters. From the first one on, it tries to apply each rewriter to the expression and sub-expressions of the expression, top-down and depth-first. If a rewriter succeeds, `RewriteOnce` substitutes the result for the original rewritten sub-expression, and returns the overall, new expression with the rewritten sub-expression. 

`RewriteOnce`, as the name indicates, does a single rewriting. If we wish to keep applying a list of rewriters to an expression until no more rewritings are possible, we can use a rewriter called `ExhaustiveRewriter`. An exhaustive rewriter takes some other rewriter (typically a `RewriteOnce` rewriter containing a list of rewriters) and keeps applying it until no more rewritings are done. Similarly, `TotalRewriter` exhaustively rewrites an expression until no more rewriting is possible but instead takes a list of rewriters to apply (this is essentially an optimized version of the `ExhaustiveRewriter` and `RewriteOnce` rewrite mechanism, as it reduces the overhead needed in between each individual rewrite call).

The most common way of using grinder is, thus, having a list of rewriters able to perform a task in some domain of interest, and using them in conjunction with `RewriteOnce` and `ExhaustiveRewriter` or `TotalRewriter`. Typically, the "most useful" rewriters will be at the top of this list, since they will be attempted first. One such rewriter is, for example, one that replaces `0 * Something`, where `Something` is some potentially complex expression, by `0`, since that eliminates a potentially complex sub-expression at a very low cost. Note that applying rewriters top-down makes sense here too. If we did it bottom-up, then we would try to apply rewriters inside `Something` before "noticing" that it can simply be eliminated. Another way of looking at this is that the top-down ordering lends a "lazy evaluation" aspect to the rewriting. 

There is a large, and ever growing, library of rewriters contained in grinder, for dealing with basic mathematics constructs such as numbers, booleans and sets. The rewriters are the part of grinder which actually implements the semantics of expressions. They work in groups, and sometimes communicate with one another during processing. Often, a rewriter uses, as a pre-condition, the fact that some other rewriter must have attempted a rewriting first (that is, is placed higher up in the list of rewriters). For example, rewriters computing the cardinality of sets assume that other rewriters normalizing set condition formulas are applied earlier and that, therefore, those conditions must already be normalized when expressions get to them. Right now, the user must make sure the required rewriters are present and placed before the ones requiring them; a planned future feature is having a rewriter "requires" declaration that automatically does that. Other relationships between rewriters will become clearer as we explain the main groups of rewriters:

  * [GrinderArithmetic Arithmetic]
  * [GrinderSets Sets]
  * [GrinderLogic Logic]
  * [ModelCountingOverview Model Counting]
  * [GrinderOtherBasicRewriters Other Basic Rewriters]

===Rewriting Process===
Rewriters usually operate in groups, forming a process we call _rewriting process_. A `RewritingProcess` is an interface representing such entities. It provides methods for determining the top expression being processed, a means to find one of its rewriters (sometimes rewriters need to find each other and communicate; see Modules), as well as a means to notify all rewriters that the process is about to start.

A rewriter is not associated with any specific process, however, since it can be part of several. Therefore, it does not have a method or field indicating "its process". Instead, the rewriter receives the process in question as an argument of its rewriting method. It can then access the process's properties as needed for that particular rewriting operation.   

===Modules===
Rewriters often rely on properties of expressions in order to modify them. The rewriter utility `Substitute`, for example, needs to know that `{(on X) f(X)}` scopes `X` in its sub-expressions. It would be simple to hard-code this fact in the system, but if a user wants to introduce some other type of expression that also scopes variables (for example, an "at least" quantifier such as `at least 20 values of X in SomeSet: odd(X)`), then `Substitute` would not know about that fact.

Instead, we use the notion of _modules_. A module object exposes an interface for a particular type of property. The module `ScopedVariables`, for instance, has methods indicating what are the scoping variables in any given expression such as the example above. When a user introduces a new function scoping variables, he or she writes a class implementing the `ScopedVariables.Provider` interface and _registers_ it with the module when a rewriting process is initiated. This way, the user does not have to modify `ScopedVariables`, but simply writes a provider, which is like a plug-in containing specific semantic knowledge about a type of expression. In fact, providers are used for all scoping functions in the system, for e.g. intensional sets, which could have been written by any user.

There are other modules for other types of properties as well. For example, it is sometimes useful to know that a function is injective, because if `f` is injective then we know that `f(X)=f(a)` is equivalent to `X=a`. The module `InjectiveModule` takes care of that, and can have its own providers registered for particular types of functions introduced by a user. 

Other current modules are `MutuallyExclusiveCoDomainsModule` and `ExpressionKnowledgeModule`. 

*Note:* currently, modules are implemented as rewriters (that usually don't perform any rewriting and therefore also implement the `NoOpRewriter` interface), but this will eventually not be true. The reason this was done so was because there was a need for rewriters to find a module upon the beginning of a rewriting process, so they can register specific providers with it. Since there was already a `RewritingProcess` method for finding rewriters, modules were created as rewriters so they can be found in the same way. However, this requires modules to have a rewriting method, which should not be necessary. At some point, we will abstract the notion of "something that can be found in a rewriting process" that will be extended by both rewriters and modules.  

  