#summary R_card_conjunction( | F |_X, quantification )
R_card_conjunction( | F |,,X,,, quantification )
<pre>
inputs: F is False, True, a literal, a multi-equality, or a conjunction.
        "quantification" is either "there exists", "for all", or "none".
return: a basic expression equivalent to | F |_X, if quantification is "none".
        If quantification is "for all", returns a counting-solution, the leaves 
            of which may differ from the exact one in the following way: 
            when the exact one is not ||X||, it may be any value but ||X||.
        If quantification is "there exists", returns a counting-solution, the leaves 
            of which may differ from the exact one in the following way: 
            when the exact one is not 0, it may be any value but 0.
</pre>
`if F is a conjunction which can be partitioned into two or more independent sub problems`<br>
// i.e. there is a partition {I,,1,,, ..., I,,k,,} of indices such that there is a partition {C,,1,,, ..., C,,k,,}<br>
// of the conjuncts of F where indices in I,,j,, occur in C,,j,, only, for every j:
    `if I`,,1,,` is empty:`
        `return if C`,,1,,` then `[RewriterSimplify R_simplify]`(`
            [RewriterCardWithQuantification R_card]`(|`[RewriterTopSimplify R_top_simplify]`(C`,,2,,`)|`,,I2,,`, quantification)  * ... *`<br>
            [RewriterCardWithQuantification R_card]`(|`[RewriterTopSimplify R_top_simplify]`(C`,,k,,`)|`,,Ik,,`, quantification) ) else 0`
    `else`
        `return `[RewriterSimplify R_simplify]`(` 
            [RewriterCardWithQuantification R_card]`(|`[RewriterTopSimplify R_top_simplify]`(C`,,1,,`)|`,,I1,,`, quantification)  * ... *` <br>
            [RewriterCardWithQuantification R_card]`(|`[RewriterTopSimplify R_top_simplify]`(C`,,k,,`)|`,,Ik,,`, quantification) )`

`if F is True or empty conjunction`
    `return ||X||`

`if F is False`
    `return 0`

`if F is F1 and F2 where F1 is a formula independent of all x's in X`
    // note that F1 is the conjunction of all conjuncts of F that are X-independent,<br>
    // or F itself if it is X-free<br>
    `F2 = `[RewriterTopSimplifyConjunction R_top_simplify_conjunction]`(F2)`<br>
    `return `[RewriterSimplify R_simplify]`( if F1 then `[RewriterCardConjunction R_card_conjunction]`(| F2 |`,,X,,`, quantification) else 0 )`<br>

`if F is a conjunction of the form 'x = t and Phi', where x is one of the index variables in X`
    `return `[RewriterEqualityInConjunction R_equality_in_conjunction]`(| F |`,,X,,`, quantification)`

`if F is x1 != t1 and ... xn != tk` // F is a conjunction of disequalities
    `return `[RewriterCardConjunctionOfDisequalities R_card_conjunction_of_disequalities]`(| F |`,,X,,`, quantification)`

`Candidates <- { (Fi, i) : Fi satisfies one of the cases below }`<br>
`(Fi, i) <- `[FunctionPickCheapest pick_cheapest]`( Candidates )`

`if Fi is "not G"`
    `return `[RewriterCardWithQuantification R_card]`(|`[FunctionReplaceConjunctAndTopSimplify replace_conjunct_and_top_simplify]`(`[RewriterMoveNotIn R_move_not_in]`(Fi), i, F)|`,,X,,`, quantification )`

if Fi is (nested) conjunction (G1 and … and Gk)
    return R_card(| R_top_simplify_conjunction(F1 and ... Fi-1 and G1 and ... and Gk and Fi+1 and … and Fn) |_X, quantification )

if Fi is G1 => G2
    return R_card(
        | top_simplify_disjunction(replace_conjunct_and_top_simplify((not G1), i, F)<br>
        or<br>
        replace_conjunct_and_top_simplify(G2, i, F)) |_X, quantification )<br>


if Fi is G1 <=> G2
    return R_card(
        | replace_conjunct_and_top_simplify(G1 and G2), i, F) |_X, quantification)<br> 
        + R_card(<br>
        | replace_conjunct_and_top_simplify(not G1 and not G2), i, F) |_X, quantification)<br>

if Fi is (F1 or F2)
    return R_card(
        | top_simplify_disjunction(replace_conjunct_and_top_simplify(F1, i, F)
        or<br>
        replace_conjunct_and_top_simplify(F2, i, F)) |_X, quantification )

if Fi is Q y : G
    return R_card(| replace_conjunct_and_top_simplify(R_top_quantifier_elimination(Fi), i, F) |_X, quantification )