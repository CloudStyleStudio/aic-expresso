#summary R_card_conjunction( | F |_X, quantification )
R_card_conjunction( | F |,,X,,, quantification )
<pre>
inputs: F is False, True, a literal, a multi-equality, or a conjunction.
        "quantification" is either "there exists", "for all", or "none".
return: a basic expression equivalent to | F |_X, if quantification is "none".
        If quantification is "for all", returns a counting-solution, the leaves 
            of which may differ from the exact one in the following way: 
            when the exact one is not ||X||, it may be any value but ||X||.
        If quantification is "there exists", returns a counting-solution, the leaves 
            of which may differ from the exact one in the following way: 
            when the exact one is not 0, it may be any value but 0.
</pre>
`if F is a conjunction which can be partitioned into two or more independent sub problems`<br>
// i.e. there is a partition {I,,1,,, ..., I,,k,,} of indices such that there is a partition {C,,1,,, ..., C,,k,,}<br>
// of the conjuncts of F where indices in I,,j,, occur in C,,j,, only, for every j:
    if I_1 is empty:
        return 
            if C_1 then R_simplify(<br>
            R_card(|R_top_simplify(C_2)|_I_2, quantification)  * ... *<br>
            R_card(|R_top_simplify(C_k)|_I_k, quantification) ) else 0<br>
    else
        return 
            R_simplify( R_card(|R_top_simplify(C_1)|_I_1, quantification)  * ... * <br>
            R_card(|R_top_simplify(C_k)|_I_k, quantification) )

if F is True or empty conjunction
    `return ||X||`

if F is False
    return 0

if F is F1 and F2 where F1 is a formula independent of all x’s in X
    // note that F1 is the conjunction of all conjuncts of F that are X-independent,<br>
    // or F itself if it is X-free<br>
    F2 = R_top_simplify_conjunction(F2)<br>
    return R_simplify( if F1 then R_card_conjunction(| F2 |_X, quantification) else 0 )<br>

if F is a conjunction of the form 'x = t and Phi', where x is one of the index variables in X
    return R_equality_in_conjunction(| F |_X, quantification)

if F is x1 != t1 and ... xn != tk // F is a conjunction of disequalities
    return R_conjunction_disequalities(| F |_X, quantification)

Candidates <- { (Fi, i) : Fi satisfies one of the cases below }<br>
(Fi, i) <- pick_cheapest( Candidates )

if Fi is “ not G ”
    return R_card(|replace_conjunct_and_top_simplify(R_move_not_in(Fi), i, F)|_X, quantification )

if Fi is (nested) conjunction (G1 and … and Gk)
    return R_card(| R_top_simplify_conjunction(F1 and ... Fi-1 and G1 and ... and Gk and Fi+1 and … and Fn) |_X, quantification )

if Fi is G1 => G2
    return R_card(
        | top_simplify_disjunction(replace_conjunct_and_top_simplify((not G1), i, F)<br>
        or<br>
        replace_conjunct_and_top_simplify(G2, i, F)) |_X, quantification )<br>


if Fi is G1 <=> G2
    return R_card(
        | replace_conjunct_and_top_simplify(G1 and G2), i, F) |_X, quantification)<br> 
        + R_card(<br>
        | replace_conjunct_and_top_simplify(not G1 and not G2), i, F) |_X, quantification)<br>

if Fi is (F1 or F2)
    return R_card(
        | top_simplify_disjunction(replace_conjunct_and_top_simplify(F1, i, F)
        or<br>
        replace_conjunct_and_top_simplify(F2, i, F)) |_X, quantification )

if Fi is Q y : G
    return R_card(| replace_conjunct_and_top_simplify(R_top_quantifier_elimination(Fi), i, F) |_X, quantification )